<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Player tests</title>
<link rel="stylesheet" href="qunit.css">
</head>
<body>
<div id="qunit"></div>
<div id="qunit-fixture"></div>
<script src="web-animations.js"></script>
<script src="qunit.js"></script>
<script src="qunit-assert-close.js"></script>
<script>
test("Initial state", function() {
  var anim = new Animation(null, null,{ duration: 3 });
  equal(anim.player, null, "Player should be null initially");

  // Check state after playing
  document.timeline.play(anim);
  notEqual(anim.player, null, "Player should be not be null when playing");
  equal(anim.player.source, anim, "Initial source content");
  equal(anim.player.timeline, document.timeline, "Initial document timeline");
  equal(anim.player.startTime, document.timeline.currentTime,
        "Initial start time");
  equal(anim.player.currentTime, 0, "Initial current time");
  equal(anim.player.timeLag, 0, "Initial time lag");
  equal(anim.player.playbackRate, 1, "Initial playback rate");
  equal(anim.player.paused, false, "Initial paused state");
  equal(anim.player.playing, true, "Initial playing state");

  // Finish
  anim.player.cancel();
});

test("Pause", function() {
  var player =
    document.timeline.play(new Animation(null, null, { duration: 3 }));

  // Pause
  player.pause();
  equal(player.paused, true, "Paused state after pausing");
  equal(player.playing, false, "Playing state after pausing");

  // Unpause
  player.play();
  equal(player.paused, false, "Paused state after unpausing");
  equal(player.playing, true, "Playing state after unpausing");

  // Finish
  player.cancel();
});

asyncTest("Seek behind content (forwards)", function() {
  var player =
    document.timeline.play(new Animation(null, null, { duration: 3 }));

  // Seek before start
  player.currentTime = -0.1;
  equal(player.currentTime, -0.1, "Current time after seeking before start");
  equal(player.paused, false, "Paused state after seeking before start");
  equal(player.playing, false, "Playing state after seeking before start");

  // Check player does not progress
  setTimeout(function() {
    equal(player.currentTime, -0.1, "Current time should not progress");

    // Finish
    player.cancel();
    start();
  }, 200);
});

asyncTest("Bounding at start", function(assert) {
  var player =
    document.timeline.play(new Animation(null, null, { duration: 3 }));

  // Set start time in the future
  player.startTime = document.timeline.currentTime + 0.1;

  // Check state of player
  equal(player.currentTime, 0, "Current time while waiting to start");
  equal(player.paused, false, "Paused state while waiting to start");
  equal(player.playing, false, "Playing state while waiting to start");

  // Check player starts automatically
  setTimeout(function() {
    assert.close(player.currentTime, 0.1, 0.05, "Current time should progress");
    equal(player.paused, false, "Paused state after starting");
    equal(player.playing, true, "Playing state after starting");

    // Finish
    player.cancel();
    start();
  }, 200);
});

asyncTest("Bounding at end (seek with current time)", function(assert) {
  var player =
    document.timeline.play(new Animation(null, null, { duration: 3 }));

  // Seek to just before end
  player.currentTime = 2.9;

  // Check state of player
  assert.close(player.currentTime, 2.9, 0.01, "Current time just before end");
  equal(player.paused, false, "Paused state just before end");
  equal(player.playing, true, "Playing state just before end");

  // Check player after finishing
  setTimeout(function() {
    assert.close(player.currentTime, 3.0, 0.05,
                 "Current time when bounded progress");
    equal(player.paused, false, "Paused state after ending");
    equal(player.playing, false, "Playing state after ending");

    // Finish
    player.cancel();
    start();
  }, 200);
});

asyncTest("Bounding at end (seek with start time)", function(assert) {
  var player =
    document.timeline.play(new Animation(null, null, { duration: 3 }));

  // Seek to just before end using the start time
  player.startTime -= 2.9;

  // Check state of player
  assert.close(player.currentTime, 2.9, 0.01, "Current time just before end");
  equal(player.paused, false, "Paused state just before end");
  equal(player.playing, true, "Playing state just before end");

  // Check player after finishing
  setTimeout(function() {
    assert.close(player.currentTime, 3.0, 0.05,
                 "Current time when bounded progress");
    equal(player.paused, false, "Paused state after ending");
    equal(player.playing, false, "Playing state after ending");

    // Finish
    player.cancel();
    start();
  }, 200);
});

asyncTest("reverse() before start", function() {
  var player =
    document.timeline.play(new Animation(null, null, { duration: 3 }));

  // Seek before start
  player.currentTime = -0.1;

  // Reverse
  player.reverse();
  equal(player.currentTime, -0.1, "Current time after reversing");
  equal(player.playing, false, "Playing state after reversing");
  equal(player.playbackRate, -1, "Playback rate after reversing");

  // Check player after some time
  setTimeout(function() {
    equal(player.currentTime, -0.1, "Current time later");
    equal(player.playing, false, "Playing state later");

    // Finish
    player.cancel();
    start();
  }, 200);
});

asyncTest("reverse() at start", function() {
  var player =
    document.timeline.play(new Animation(null, null, { duration: 3 }));

  // Reverse
  player.reverse();
  equal(player.currentTime, 0, "Current time after reversing");
  equal(player.playing, false, "Playing state after reversing");
  equal(player.playbackRate, -1, "Playback rate after reversing");

  // Check player after some time
  setTimeout(function() {
    equal(player.currentTime, 0, "Current time later");
    equal(player.playing, false, "Playing state later");

    // Finish
    player.cancel();
    start();
  }, 200);
});

asyncTest("reverse() while playing", function(assert) {
  var player =
    document.timeline.play(new Animation(null, null, { duration: 3 }));

  // Seek midway
  player.currentTime = 1.5;

  // Reverse
  player.reverse();
  equal(player.currentTime, 1.5, "Current time after reversing");
  equal(player.playing, true, "Playing state after reversing");
  equal(player.playbackRate, -1, "Playback rate after reversing");

  // Check player after some time
  setTimeout(function() {
    assert.close(player.currentTime, 1.3, 0.05, "Current time when reversing");
    equal(player.playing, true, "Playing state later");

    // Finish
    player.cancel();
    start();
  }, 200);
});

asyncTest("reverse() when finished", function(assert) {
  var player =
    document.timeline.play(new Animation(null, null, { duration: 3 }));

  // Seek to just before the end
  player.currentTime = 2.9;

  // Wait to finish
  setTimeout(function() {
    assert.close(player.currentTime, 3.0, 0.01, "Current time when finished");
    equal(player.playing, false, "Playing state after finished");

    // Reverse
    player.reverse();
    equal(player.currentTime, 3.0, "Current time after reversing");
    equal(player.playing, true, "Playing state after reversing");
    equal(player.playbackRate, -1, "Playback rate after reversing");

    // Check we actually reverse
    setTimeout(function() {
      assert.close(player.currentTime, 2.8, 0.1,
                   "Current time after beginning reverse");
      equal(player.playing, true, "Playing state after reversing");

      // Finish
      player.cancel();
      start();
    }, 200);
  }, 200);
});

asyncTest("reverse() when seeked past end", function(assert) {
  var player =
    document.timeline.play(new Animation(null, null, { duration: 3 }));

  // Seek to past the end
  player.currentTime = 4.0

  // Check it is bounded
  setTimeout(function() {
    equal(player.currentTime, 4.0, "Current time when seeked past end");
    equal(player.playing, false, "Playing state when seeked past end");

    // Reverse
    player.reverse();
    equal(player.currentTime, 3.0, "Current time after reversing");
    equal(player.playing, true, "Playing state after reversing");
    equal(player.playbackRate, -1, "Playback rate after reversing");

    // Check we actually reverse
    setTimeout(function() {
      assert.close(player.currentTime, 2.8, 0.1,
                   "Current time after beginning reverse");
      equal(player.playing, true, "Playing state after reversing");

      // Finish
      player.cancel();
      start();
    }, 200);
  }, 200);
});

test("Set startTime on bounded player to put it in range", function(assert) {
  var player =
    document.timeline.play(new Animation(null, null, { duration: 3 }));

  player.startTime = document.timeline.currentTime + 1;

  // Check player is bounded
  equal(player.currentTime, 0, "currentTime while waiting to start");
  equal(player.playing, false, "playing state while waiting to start");

  // Then put it in range
  player.startTime -= 2;
  assert.close(player.currentTime, 1, 0.1,
               "currentTime after updating start time");
  equal(player.playing, true, "playing state while after updating start time");

  // Finish
  player.cancel();
});

asyncTest("Set startTime on bounded player to leave it still before start",
function(assert) {
  var player =
    document.timeline.play(new Animation(null, null, { duration: 3 }));

  player.startTime = document.timeline.currentTime + 1;

  // Check player is bounded
  equal(player.currentTime, 0, "currentTime while waiting to start");
  equal(player.playing, false, "playing state while waiting to start");

  // Then adjust start time
  player.startTime -= 0.8;

  // Check player is *still* bounded
  equal(player.currentTime, 0, "currentTime while still waiting to start");
  equal(player.playing, false, "playing state while still waiting to start");

  // Verify the time *did* update though
  setTimeout(function() {
    assert.close(player.currentTime, 0.2, 0.1,
                 "Current time after starting to play");
    equal(player.playing, true, "Playing state after starting to play");

    // Finish
    player.cancel();
    start();
  }, 400);
});

test("Set startTime on bounded player to put past the end", function(assert) {
  var player =
    document.timeline.play(new Animation(null, null, { duration: 3 }));

  player.startTime = document.timeline.currentTime + 1;

  // Check player is bounded
  equal(player.currentTime, 0, "currentTime while waiting to start");
  equal(player.playing, false, "playing state while waiting to start");

  // Then put it past the end
  player.startTime -= 5;
  equal(player.currentTime, 3, "currentTime after end");
  equal(player.playing, false, "playing state after end");

  // Finish
  player.cancel();
});

asyncTest("Reversing playbackRate before start", function(assert) {
  // Set up player to start in 1s
  var player =
    document.timeline.play(new Animation(null, null, { duration: 3 }));
  player.startTime = document.timeline.currentTime + 0.1;

  // Check state
  equal(player.currentTime, 0, "currentTime while waiting to start");
  equal(player.playing, false, "playing state while waiting to start");

  // Reverse playbackRate
  player.playbackRate = -1;

  // We should maintain the same current time
  equal(player.currentTime, 0, "currentTime after updating playbackRate");
  equal(player.playing, false, "playing state after updating playbackRate");

  // If we wait a while we should be stuck at the end
  setTimeout(function() {
    equal(player.currentTime, 0, "currentTime after waiting");
    equal(player.playing, false, "playing state after waiting");

    // Call play and we should start from the end
    player.play();
    equal(player.currentTime, 3, "currentTime after play()");
    equal(player.playing, true, "playing state after play()");

    // Finish
    player.cancel();
    start();
  }, 200);
});
</script>
</body>
</html>
